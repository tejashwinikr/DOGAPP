{"ast":null,"code":"import { addErrorToMonitoringBatch, addEventListener, monitor } from '@datadog/browser-core';\nimport { LifeCycleEventType } from '@datadog/browser-rum-core';\nimport { SEND_BEACON_BYTE_LENGTH_LIMIT } from '../../transport/send';\nimport { createDeflateWorker } from './deflateWorker';\nimport { Segment } from './segment';\nexport var MAX_SEGMENT_DURATION = 30000;\nvar MAX_SEGMENT_SIZE = SEND_BEACON_BYTE_LENGTH_LIMIT; // Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (meta), so our goal is to\n// build segments containing as much records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment size reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nvar workerSingleton;\nexport function startSegmentCollection(lifeCycle, applicationId, session, parentContexts, send) {\n  if (!workerSingleton) {\n    workerSingleton = createDeflateWorker();\n    workerSingleton.addEventListener('message', monitor(function (_a) {\n      var data = _a.data;\n\n      if ('error' in data) {\n        addErrorToMonitoringBatch(data.error);\n      }\n    }));\n  }\n\n  return doStartSegmentCollection(lifeCycle, function () {\n    return computeSegmentContext(applicationId, session, parentContexts);\n  }, send, workerSingleton);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, send, worker, emitter) {\n  if (emitter === void 0) {\n    emitter = window;\n  }\n\n  var state = {\n    status: 0\n    /* WaitingForInitialRecord */\n    ,\n    nextSegmentCreationReason: 'init'\n  };\n  var unsubscribeViewCreated = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, function () {\n    flushSegment('view_change');\n  }).unsubscribe;\n  var unsubscribeBeforeUnload = lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, function () {\n    flushSegment('before_unload');\n  }).unsubscribe;\n  var unsubscribeVisibilityChange = addEventListener(emitter, \"visibilitychange\"\n  /* VISIBILITY_CHANGE */\n  , function () {\n    if (document.visibilityState === 'hidden') {\n      flushSegment('visibility_hidden');\n    }\n  }, {\n    capture: true\n  }).stop;\n\n  function flushSegment(nextSegmentCreationReason) {\n    if (state.status === 1\n    /* SegmentPending */\n    ) {\n      state.segment.flush();\n      clearTimeout(state.expirationTimeoutId);\n    }\n\n    if (nextSegmentCreationReason) {\n      state = {\n        status: 0\n        /* WaitingForInitialRecord */\n        ,\n        nextSegmentCreationReason: nextSegmentCreationReason\n      };\n    } else {\n      state = {\n        status: 2\n        /* Stopped */\n\n      };\n    }\n  }\n\n  function createNewSegment(creationReason, initialRecord) {\n    var context = getSegmentContext();\n\n    if (!context) {\n      return;\n    }\n\n    var segment = new Segment(worker, context, creationReason, initialRecord, function (compressedSegmentSize) {\n      if (!segment.isFlushed && compressedSegmentSize > MAX_SEGMENT_SIZE) {\n        flushSegment('max_size');\n      }\n    }, function (data, rawSegmentSize) {\n      send(data, segment.meta, rawSegmentSize);\n    });\n    state = {\n      status: 1\n      /* SegmentPending */\n      ,\n      segment: segment,\n      expirationTimeoutId: setTimeout(monitor(function () {\n        flushSegment('max_duration');\n      }), MAX_SEGMENT_DURATION)\n    };\n  }\n\n  return {\n    addRecord: function addRecord(record) {\n      switch (state.status) {\n        case 0\n        /* WaitingForInitialRecord */\n        :\n          createNewSegment(state.nextSegmentCreationReason, record);\n          break;\n\n        case 1\n        /* SegmentPending */\n        :\n          state.segment.addRecord(record);\n          break;\n      }\n    },\n    stop: function stop() {\n      flushSegment();\n      unsubscribeViewCreated();\n      unsubscribeBeforeUnload();\n      unsubscribeVisibilityChange();\n    }\n  };\n}\nexport function computeSegmentContext(applicationId, session, parentContexts) {\n  if (!session.isTracked()) {\n    return undefined;\n  }\n\n  var viewContext = parentContexts.findView();\n\n  if (!(viewContext === null || viewContext === void 0 ? void 0 : viewContext.session.id) || viewContext.session.id !== session.getId()) {\n    return undefined;\n  }\n\n  return {\n    application: {\n      id: applicationId\n    },\n    session: {\n      id: viewContext.session.id\n    },\n    view: {\n      id: viewContext.view.id\n    }\n  };\n}\nexport function setMaxSegmentSize(newSize) {\n  if (newSize === void 0) {\n    newSize = SEND_BEACON_BYTE_LENGTH_LIMIT;\n  }\n\n  MAX_SEGMENT_SIZE = newSize;\n}","map":{"version":3,"mappings":"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","names":["addErrorToMonitoringBatch","addEventListener","monitor","LifeCycleEventType","SEND_BEACON_BYTE_LENGTH_LIMIT","createDeflateWorker","Segment","MAX_SEGMENT_DURATION","MAX_SEGMENT_SIZE","workerSingleton","startSegmentCollection","lifeCycle","applicationId","session","parentContexts","send","_a","data","error","doStartSegmentCollection","getSegmentContext","worker","emitter","state","status","nextSegmentCreationReason","unsubscribeViewCreated","subscribe","VIEW_CREATED","flushSegment","unsubscribe","unsubscribeBeforeUnload","BEFORE_UNLOAD","unsubscribeVisibilityChange","document","visibilityState","capture","stop","segment","flush","clearTimeout","expirationTimeoutId","createNewSegment","creationReason","initialRecord","context","compressedSegmentSize","isFlushed","rawSegmentSize","meta","setTimeout","addRecord","record","computeSegmentContext","isTracked","undefined","viewContext","findView","id","getId","application","view","setMaxSegmentSize","newSize"],"sourceRoot":"","sources":["../../../src/domain/segmentCollection/segmentCollection.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}