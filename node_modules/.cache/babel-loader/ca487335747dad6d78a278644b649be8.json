{"ast":null,"code":"import { safeTruncate } from '@datadog/browser-core';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\n\nvar DEFAULT_PROGRAMMATIC_ATTRIBUTE = 'data-dd-action-name';\nexport function getActionNameFromElement(element, userProgrammaticAttribute) {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ATTRIBUTE) || userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute) || getActionNameFromElementForStrategies(element, priorityStrategies) || getActionNameFromElementForStrategies(element, fallbackStrategies) || '';\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n  var elementWithAttribute; // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(\"[\" + programmaticAttribute + \"]\");\n  } else {\n    var element = targetElement;\n\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element;\n        break;\n      }\n\n      element = element.parentElement;\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return;\n  }\n\n  var name = elementWithAttribute.getAttribute(programmaticAttribute);\n  return truncate(normalizeWhitespace(name.trim()));\n}\n\nvar priorityStrategies = [// associated LABEL text\nfunction (element) {\n  // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n  // instead\n  if (supportsLabelProperty()) {\n    if ('labels' in element && element.labels && element.labels.length > 0) {\n      return getTextualContent(element.labels[0]);\n    }\n  } else if (element.id) {\n    var label = element.ownerDocument && element.ownerDocument.querySelector(\"label[for=\\\"\" + element.id.replace('\"', '\\\\\"') + \"\\\"]\");\n    return label && getTextualContent(label);\n  }\n}, // INPUT button (and associated) value\nfunction (element) {\n  if (element.nodeName === 'INPUT') {\n    var input = element;\n    var type = input.getAttribute('type');\n\n    if (type === 'button' || type === 'submit' || type === 'reset') {\n      return input.value;\n    }\n  }\n}, // BUTTON, LABEL or button-like element text\nfunction (element) {\n  if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n    return getTextualContent(element);\n  }\n}, function (element) {\n  return element.getAttribute('aria-label');\n}, // associated element text designated by the aria-labelledby attribute\nfunction (element) {\n  var labelledByAttribute = element.getAttribute('aria-labelledby');\n\n  if (labelledByAttribute) {\n    return labelledByAttribute.split(/\\s+/).map(function (id) {\n      return getElementById(element, id);\n    }).filter(function (label) {\n      return Boolean(label);\n    }).map(getTextualContent).join(' ');\n  }\n}, function (element) {\n  return element.getAttribute('alt');\n}, function (element) {\n  return element.getAttribute('name');\n}, function (element) {\n  return element.getAttribute('title');\n}, function (element) {\n  return element.getAttribute('placeholder');\n}, // SELECT first OPTION text\nfunction (element) {\n  if ('options' in element && element.options.length > 0) {\n    return getTextualContent(element.options[0]);\n  }\n}];\nvar fallbackStrategies = [function (element) {\n  return getTextualContent(element);\n}];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\n\nvar MAX_PARENTS_TO_CONSIDER = 10;\n\nfunction getActionNameFromElementForStrategies(targetElement, strategies) {\n  var element = targetElement;\n  var recursionCounter = 0;\n\n  while (recursionCounter <= MAX_PARENTS_TO_CONSIDER && element && element.nodeName !== 'BODY' && element.nodeName !== 'HTML' && element.nodeName !== 'HEAD') {\n    for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {\n      var strategy = strategies_1[_i];\n      var name_1 = strategy(element);\n\n      if (typeof name_1 === 'string') {\n        var trimmedName = name_1.trim();\n\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName));\n        }\n      }\n    } // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n\n\n    if (element.nodeName === 'FORM') {\n      break;\n    }\n\n    element = element.parentElement;\n    recursionCounter += 1;\n  }\n}\n\nfunction normalizeWhitespace(s) {\n  return s.replace(/\\s+/g, ' ');\n}\n\nfunction truncate(s) {\n  return s.length > 100 ? safeTruncate(s, 100) + \" [...]\" : s;\n}\n\nfunction getElementById(refElement, id) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\n\nfunction getTextualContent(element) {\n  if (element.isContentEditable) {\n    return;\n  }\n\n  if ('innerText' in element) {\n    var text = element.innerText;\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      var elementsTextToRemove = element.querySelectorAll('script, style'); // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n      for (var i = 0; i < elementsTextToRemove.length; i += 1) {\n        var innerText = elementsTextToRemove[i].innerText;\n\n        if (innerText.trim().length > 0) {\n          text = text.replace(innerText, '');\n        }\n      }\n    }\n\n    return text;\n  }\n\n  return element.textContent;\n}\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element.  This\n * should be the case everywhere except on some version of Internet Explorer.\n * See http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n */\n\n\nvar supportsInnerTextScriptAndStyleRemovalResult;\n\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  if (supportsInnerTextScriptAndStyleRemovalResult === undefined) {\n    var style = document.createElement('style');\n    style.textContent = '*';\n    var div = document.createElement('div');\n    div.appendChild(style);\n    document.body.appendChild(div);\n    supportsInnerTextScriptAndStyleRemovalResult = div.innerText === '';\n    document.body.removeChild(div);\n  }\n\n  return supportsInnerTextScriptAndStyleRemovalResult;\n}\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\n\n\nvar supportsLabelPropertyResult;\n\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;\n  }\n\n  return supportsLabelPropertyResult;\n}\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\n\n\nvar supportsElementClosestResult;\n\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype;\n  }\n\n  return supportsElementClosestResult;\n}","map":{"version":3,"mappings":"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","names":["safeTruncate","DEFAULT_PROGRAMMATIC_ATTRIBUTE","getActionNameFromElement","element","userProgrammaticAttribute","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosest","closest","hasAttribute","parentElement","name","getAttribute","truncate","normalizeWhitespace","trim","supportsLabelProperty","labels","length","getTextualContent","id","label","ownerDocument","querySelector","replace","nodeName","input","type","value","labelledByAttribute","split","map","filter","join","options","MAX_PARENTS_TO_CONSIDER","strategies","recursionCounter","_i","strategy","name_1","trimmedName","s","getElementById","refElement","isContentEditable","text","innerText","supportsInnerTextScriptAndStyleRemoval","elementsTextToRemove","querySelectorAll","i","textContent","supportsInnerTextScriptAndStyleRemovalResult","undefined","style","document","createElement","div","appendChild","body","removeChild","supportsLabelPropertyResult","HTMLInputElement","prototype","supportsElementClosestResult","HTMLElement"],"sourceRoot":"","sources":["../../../../src/domain/rumEventsCollection/action/getActionNameFromElement.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}