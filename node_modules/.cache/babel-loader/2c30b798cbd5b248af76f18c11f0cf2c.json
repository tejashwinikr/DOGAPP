{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { addMonitoringMessage, monitor } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nvar nextId = 0;\n\nvar Segment =\n/** @class */\nfunction () {\n  function Segment(worker, context, creationReason, initialRecord, onWrote, onFlushed) {\n    var _this = this;\n\n    this.worker = worker;\n    this.context = context;\n    this.creationReason = creationReason;\n    this.isFlushed = false;\n    this.id = nextId++;\n    this.start = initialRecord.timestamp;\n    this.end = initialRecord.timestamp;\n    this.recordsCount = 1;\n    this.hasFullSnapshot = initialRecord.type === RecordType.FullSnapshot;\n    var viewId = this.context.view.id;\n    replayStats.addSegment(viewId);\n    replayStats.addRecord(viewId);\n    var listener = monitor(function (_a) {\n      var data = _a.data;\n\n      if ('error' in data) {\n        return;\n      }\n\n      if (data.id === _this.id) {\n        replayStats.addWroteData(viewId, data.additionalRawSize);\n\n        if ('result' in data) {\n          onFlushed(data.result, data.rawSize);\n          worker.removeEventListener('message', listener);\n        } else {\n          onWrote(data.compressedSize);\n        }\n      } else if (data.id > _this.id) {\n        // Messages should be received in the same order as they are sent, so if we receive a\n        // message with an id superior to this Segment instance id, we know that another, more\n        // recent Segment instance is being used.\n        //\n        // In theory, a \"flush\" response should have been received at this point, so the listener\n        // should already have been removed. But if something goes wrong and we didn't receive a\n        // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n        // help investigate the issue.\n        worker.removeEventListener('message', listener);\n        addMonitoringMessage(\"Segment did not receive a 'flush' response before being replaced.\");\n      }\n    });\n    worker.addEventListener('message', listener);\n    this.worker.postMessage({\n      data: \"{\\\"records\\\":[\" + JSON.stringify(initialRecord),\n      id: this.id,\n      action: 'write'\n    });\n  }\n\n  Segment.prototype.addRecord = function (record) {\n    this.end = record.timestamp;\n    this.recordsCount += 1;\n    replayStats.addRecord(this.context.view.id);\n    this.hasFullSnapshot || (this.hasFullSnapshot = record.type === RecordType.FullSnapshot);\n    this.worker.postMessage({\n      data: \",\" + JSON.stringify(record),\n      id: this.id,\n      action: 'write'\n    });\n  };\n\n  Segment.prototype.flush = function () {\n    this.worker.postMessage({\n      data: \"],\" + JSON.stringify(this.meta).slice(1) + \"\\n\",\n      id: this.id,\n      action: 'flush'\n    });\n    this.isFlushed = true;\n  };\n\n  Object.defineProperty(Segment.prototype, \"meta\", {\n    get: function get() {\n      return __assign({\n        creation_reason: this.creationReason,\n        end: this.end,\n        has_full_snapshot: this.hasFullSnapshot,\n        records_count: this.recordsCount,\n        start: this.start\n      }, this.context);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Segment;\n}();\n\nexport { Segment };","map":{"version":3,"mappings":"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","names":["addMonitoringMessage","monitor","RecordType","replayStats","nextId","worker","context","creationReason","initialRecord","onWrote","onFlushed","start","timestamp","end","recordsCount","hasFullSnapshot","type","FullSnapshot","viewId","view","id","addSegment","addRecord","listener","_a","data","_this","addWroteData","additionalRawSize","result","rawSize","removeEventListener","compressedSize","addEventListener","postMessage","JSON","stringify","action","Segment","record","meta","slice","isFlushed","Object","creation_reason","has_full_snapshot","records_count"],"sourceRoot":"","sources":["../../../src/domain/segmentCollection/segment.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}