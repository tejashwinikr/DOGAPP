{"ast":null,"code":"/* eslint-disable */\nvar workerURL;\nexport function createDeflateWorker() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([\"(\" + workerCodeFn + \")(self)\"]));\n  }\n\n  return new Worker(workerURL);\n}\n\nfunction workerCodeFn() {\n  monitor(function () {\n    var _a = makePakoDeflate(),\n        Deflate = _a.Deflate,\n        constants = _a.constants;\n\n    var deflate = new Deflate();\n    var rawSize = 0;\n    self.addEventListener('message', monitor(function (event) {\n      var data = event.data;\n\n      switch (data.action) {\n        case 'write':\n          var additionalRawSize = pushData(data.data);\n          self.postMessage({\n            id: data.id,\n            compressedSize: deflate.chunks.reduce(function (total, chunk) {\n              return total + chunk.length;\n            }, 0),\n            additionalRawSize: additionalRawSize\n          });\n          break;\n\n        case 'flush':\n          var additionalRawSize = data.data ? pushData(data.data) : 0;\n          deflate.push('', constants.Z_FINISH);\n          self.postMessage({\n            id: data.id,\n            result: deflate.result,\n            additionalRawSize: additionalRawSize,\n            rawSize: rawSize\n          });\n          deflate = new Deflate();\n          rawSize = 0;\n          break;\n      }\n    }));\n\n    function pushData(data) {\n      var binaryData = new TextEncoder().encode(data);\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH);\n      rawSize += binaryData.length;\n      return binaryData.length;\n    }\n  })();\n\n  function monitor(fn) {\n    return function () {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        try {\n          self.postMessage({\n            error: e\n          });\n        } catch (_) {\n          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n          self.postMessage({\n            error: '' + e\n          });\n        }\n      }\n    };\n  } // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n\n\n  function makePakoDeflate() {\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    /* eslint-disable space-unary-ops */\n\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n    // const Z_FILTERED          = 1;\n    // const Z_HUFFMAN_ONLY      = 2;\n    // const Z_RLE               = 3;\n    var Z_FIXED = 4; // const Z_DEFAULT_STRATEGY  = 0;\n\n    /* Possible values of the data_type field (though see inflate()) */\n\n    var Z_BINARY = 0;\n    var Z_TEXT = 1; // const Z_ASCII             = 1; // = Z_TEXT\n\n    var Z_UNKNOWN = 2;\n    /* ============================================================================ */\n\n    function zero(buf) {\n      var len = buf.length;\n\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    } // From zutil.h\n\n\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    /* The three kinds of block type */\n\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    /* The minimum and maximum match lengths */\n    // From deflate.h\n\n    /* ===========================================================================\n     * Internal compression state.\n     */\n\n    var LENGTH_CODES = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS = 256;\n    /* number of literal bytes 0..255 */\n\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES = 30;\n    /* number of distance codes */\n\n    var BL_CODES = 19;\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    /* maximum heap size */\n\n    var MAX_BITS = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    var Buf_size = 16;\n    /* size of bit buffer in bi_buf */\n\n    /* ===========================================================================\n     * Constants\n     */\n\n    var MAX_BL_BITS = 7;\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n    var END_BLOCK = 256;\n    /* end of block literal code */\n\n    var REP_3_6 = 16;\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n    var REPZ_3_10 = 17;\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n    var REPZ_11_138 = 18;\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n    /* eslint-disable comma-spacing,array-bracket-spacing */\n\n    var extra_lbits =\n    /* extra bits for each length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\n    var extra_dbits =\n    /* extra bits for each distance code */\n    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n    var extra_blbits =\n    /* extra bits for each bit length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\n    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n    var DIST_CODE_LEN = 512;\n    /* see definition of array dist_code below */\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n\n    var _dist_code = new Array(DIST_CODE_LEN);\n\n    zero(_dist_code);\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\n    zero(_length_code);\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    /* First normalized length for each code (0 = MIN_MATCH) */\n\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    /* First normalized distance for each code (0 = distance of 1) */\n\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      /* static tree or NULL */\n\n      this.extra_bits = extra_bits;\n      /* extra bits for each code or NULL */\n\n      this.extra_base = extra_base;\n      /* base index for extra_bits */\n\n      this.elems = elems;\n      /* max number of elements in the tree */\n\n      this.max_length = max_length;\n      /* max bit length for the codes */\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n      this.has_stree = static_tree && static_tree.length;\n    }\n\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      /* the dynamic tree */\n\n      this.max_code = 0;\n      /* largest code with non zero frequency */\n\n      this.stat_desc = stat_desc;\n      /* the corresponding static tree */\n    }\n\n    var d_code = function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    };\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n\n\n    var put_short = function put_short(s, w) {\n      //    put_byte(s, (uch)((w) & 0xff));\n      //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = w & 0xff;\n      s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n    };\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n\n\n    var send_bits = function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n      }\n    };\n\n    var send_code = function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2],\n      /* .Code */\n      tree[c * 2 + 1]\n      /* .Len */\n      );\n    };\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n\n\n    var bi_reverse = function bi_reverse(code, len) {\n      var res = 0;\n\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n\n      return res >>> 1;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n\n\n    var bi_flush = function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    };\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n\n\n    var gen_bitlen = function gen_bitlen(s, desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      /* heap index */\n\n      var n;\n      var m;\n      /* iterate over the tree elements */\n\n      var bits;\n      /* bit length */\n\n      var xbits;\n      /* extra bits */\n\n      var f;\n      /* frequency */\n\n      var overflow = 0;\n      /* number of elements with bit length too large */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n\n\n      tree[s.heap[s.heap_max] * 2 + 1] =\n      /* .Len */\n      0;\n      /* root of the heap */\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] *\n        /* .Dad */\n        2 + 1] +\n        /* .Len */\n        1;\n\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n\n        tree[n * 2 + 1] =\n        /* .Len */\n        bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) {\n          continue;\n        }\n        /* not a leaf node */\n\n\n        s.bl_count[bits]++;\n        xbits = 0;\n\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n\n        f = tree[n * 2];\n        /* .Freq */\n\n        s.opt_len += f * (bits + xbits);\n\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] +\n          /* .Len */\n          xbits);\n        }\n      }\n\n      if (overflow === 0) {\n        return;\n      } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n\n      /* Find the first bit length which could increase: */\n\n\n      do {\n        bits = max_length - 1;\n\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n\n        s.bl_count[bits]--;\n        /* move one leaf down the tree */\n\n        s.bl_count[bits + 1] += 2;\n        /* move one overflow item as its brother */\n\n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n\n        overflow -= 2;\n      } while (overflow > 0);\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n\n\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n\n        while (n !== 0) {\n          m = s.heap[--h];\n\n          if (m > max_code) {\n            continue;\n          }\n\n          if (tree[m * 2 + 1] !==\n          /* .Len */\n          bits) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len += (bits - tree[m * 2 + 1]) *\n            /* .Len */\n            tree[m * 2];\n            /* .Freq */\n\n            tree[m * 2 + 1] =\n            /* .Len */\n            bits;\n          }\n\n          n--;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n\n\n    var gen_codes = function gen_codes(tree, max_code, bl_count //    ct_data *tree;             /* the tree to decorate */ //    int max_code;              /* largest code with non zero frequency */ //    ushf *bl_count;            /* number of codes at each bit length */\n    ) {\n      var next_code = new Array(MAX_BITS + 1);\n      /* next code value for each bit length */\n\n      var code = 0;\n      /* running code value */\n\n      var bits;\n      /* bit index */\n\n      var n;\n      /* code index */\n\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        /* .Len */\n\n        if (len === 0) {\n          continue;\n        }\n        /* Now reverse the bits */\n\n\n        tree[n * 2] =\n        /* .Code */\n        bi_reverse(next_code[len]++, len); // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    };\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n\n\n    var tr_static_init = function tr_static_init() {\n      var n;\n      /* iterates over tree elements */\n\n      var bits;\n      /* bit counter */\n\n      var length;\n      /* length value */\n\n      var code;\n      /* code value */\n\n      var dist;\n      /* distance index */\n\n      var bl_count = new Array(MAX_BITS + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // do check in _tr_init()\n      // if (static_init_done) return;\n\n      /* For some embedded targets, global variables are not initialized: */\n\n      /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n      #endif */\n\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n      length = 0;\n\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      } // Assert (length == 256, \"tr_static_init: length != 256\");\n\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n\n\n      _length_code[length - 1] = code;\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n      dist = 0;\n\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n\n      dist >>= 7;\n      /* from now on, all distances are divided by 128 */\n\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n\n        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n      /* Construct the codes of the static literal tree */\n\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n\n      n = 0;\n\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        9;\n        n++;\n        bl_count[9]++;\n      }\n\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        7;\n        n++;\n        bl_count[7]++;\n      }\n\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n\n\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      /* The static distance tree is trivial: */\n\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] =\n        /* .Len */\n        5;\n        static_dtree[n * 2] =\n        /* .Code */\n        bi_reverse(n, 5);\n      } // Now data ready and we can init static trees\n\n\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); // static_init_done = true;\n    };\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n\n\n    var init_block = function init_block(s) {\n      var n;\n      /* iterates over tree elements */\n\n      /* Initialize the trees. */\n\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      s.dyn_ltree[END_BLOCK * 2] =\n      /* .Freq */\n      1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n\n\n    var bi_windup = function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        // put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    };\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n\n\n    var copy_block = function copy_block(s, buf, len, header // DeflateState *s; //charf    *buf;    /* the input data */ //unsigned len;     /* its length */ //int      header;  /* true if block header must be written */\n    ) {\n      bi_windup(s);\n      /* align on byte boundary */\n\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      } //  while (len--) {\n      //    put_byte(s, *buf++);\n      //  }\n\n\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n      s.pending += len;\n    };\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n\n\n    var smaller = function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n\n      var _m2 = m * 2;\n\n      return tree[_n2] <\n      /* .Freq */\n      tree[_m2] ||\n      /* .Freq */\n      tree[_n2] ===\n      /* .Freq */\n      tree[_m2] &&\n      /* .Freq */\n      depth[n] <= depth[m];\n    };\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n\n\n    var pqdownheap = function pqdownheap(s, tree, k //    deflate_state *s; //    ct_data *tree;  /* the tree to restore */ //    int k;               /* node to move down */\n    ) {\n      var v = s.heap[k];\n      var j = k << 1;\n      /* left son of k */\n\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        /* Exit if v is smaller than both sons */\n\n\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        /* Exchange v with the smallest son */\n\n\n        s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */\n\n        j <<= 1;\n      }\n\n      s.heap[k] = v;\n    }; // inlined manually\n    // const SMALLEST = 1;\n\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n\n\n    var compress_block = function compress_block(s, ltree, dtree //    deflate_state *s; //    const ct_data *ltree; /* literal tree */ //    const ct_data *dtree; /* distance tree */\n    ) {\n      var dist;\n      /* distance of matched string */\n\n      var lc;\n      /* match length or unmatched char (if dist == 0) */\n\n      var lx = 0;\n      /* running index in l_buf */\n\n      var code;\n      /* the code to send */\n\n      var extra;\n      /* number of extra bits to send */\n\n      if (s.last_lit !== 0) {\n        do {\n          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n            /* send a literal byte */\n            // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            /* send the length code */\n\n            extra = extra_lbits[code];\n\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n              /* send the extra length bits */\n            }\n\n            dist--;\n            /* dist is now the match distance - 1 */\n\n            code = d_code(dist); // Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);\n            /* send the distance code */\n\n            extra = extra_dbits[code];\n\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n              /* send the extra distance bits */\n            }\n          }\n          /* literal or match pair ? */\n\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n\n        } while (lx < s.last_lit);\n      }\n\n      send_code(s, END_BLOCK, ltree);\n    };\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n\n\n    var build_tree = function build_tree(s, desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n;\n      var m;\n      /* iterate over heap elements */\n\n      var max_code = -1;\n      /* largest code with non zero frequency */\n\n      var node;\n      /* new node being created */\n\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !==\n        /* .Freq */\n        0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] =\n          /* .Len */\n          0;\n        }\n      }\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n\n\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] =\n        /* .Freq */\n        1;\n        s.depth[node] = 0;\n        s.opt_len--;\n\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n          /* .Len */\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n\n      }\n\n      desc.max_code = max_code;\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n\n      for (n = s.heap_len >> 1;\n      /* int /2 */\n      n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n\n\n      node = elems;\n      /* next internal node of the tree */\n\n      do {\n        // pqremove(s, tree, n);  /* n = node of least frequency */\n\n        /** * pqremove ** */\n        n = s.heap[1];\n        /* SMALLEST */\n\n        s.heap[1] = s.heap[s.heap_len--];\n        /* SMALLEST */\n\n        pqdownheap(s, tree, 1\n        /* SMALLEST */\n        );\n        /***/\n\n        m = s.heap[1];\n        /* SMALLEST */\n\n        /* m = node of next least frequency */\n\n        s.heap[--s.heap_max] = n;\n        /* keep the nodes sorted by frequency */\n\n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */\n\n        tree[node * 2] =\n        /* .Freq */\n        tree[n * 2] +\n        /* .Freq */\n        tree[m * 2];\n        /* .Freq */\n\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] =\n        /* .Dad */\n        tree[m * 2 + 1] =\n        /* .Dad */\n        node;\n        /* and insert the new node in the heap */\n\n        s.heap[1] = node++;\n        /* SMALLEST */\n\n        pqdownheap(s, tree, 1\n        /* SMALLEST */\n        );\n      } while (s.heap_len >= 2);\n\n      s.heap[--s.heap_max] = s.heap[1];\n      /* SMALLEST */\n\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n\n      gen_bitlen(s, desc);\n      /* The field len is now set, we can generate the bit codes */\n\n      gen_codes(tree, max_code, s.bl_count);\n    };\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n\n\n    var scan_tree = function scan_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree;   /* the tree to be scanned */ //    int max_code;    /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n\n      var prevlen = -1;\n      /* last emitted length */\n\n      var curlen;\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n\n      /* length of next code */\n\n      var count = 0;\n      /* repeat count of the current code */\n\n      var max_count = 7;\n      /* max repeat count */\n\n      var min_count = 4;\n      /* min repeat count */\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      tree[(max_code + 1) * 2 + 1] =\n      /* .Len */\n      0xffff;\n      /* guard */\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] +=\n          /* .Freq */\n          count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2] /* .Freq */++;\n          }\n\n          s.bl_tree[REP_3_6 * 2] /* .Freq */++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++;\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n\n\n    var send_tree = function send_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree; /* the tree to be scanned */ //    int max_code;       /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n\n      var prevlen = -1;\n      /* last emitted length */\n\n      var curlen;\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n\n      /* length of next code */\n\n      var count = 0;\n      /* repeat count of the current code */\n\n      var max_count = 7;\n      /* max repeat count */\n\n      var min_count = 4;\n      /* min repeat count */\n\n      /* tree[max_code+1].Len = -1; */\n\n      /* guard already set */\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n\n\n    var build_bl_tree = function build_bl_tree(s) {\n      var max_blindex;\n      /* index of last bit length code of non zero freq */\n\n      /* Determine the bit length frequencies for literal and distance trees */\n\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      /* Build the bit length tree: */\n\n      build_tree(s, s.bl_desc);\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n        /* .Len */\n        0) {\n          break;\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n\n\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n\n      return max_blindex;\n    };\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n\n\n    var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    ) {\n      var rank;\n      /* index in bl_order */\n      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      // Tracev((stderr, \"\\nbl counts: \"));\n\n      send_bits(s, lcodes - 257, 5);\n      /* not +255 as stated in appnote.txt */\n\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      /* not -3 as stated in appnote.txt */\n\n      for (rank = 0; rank < blcodes; rank++) {\n        // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1],\n        /* .Len */\n        3);\n      } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      /* literal tree */\n      // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n      /* distance tree */\n      // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    };\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n\n\n    var detect_data_type = function detect_data_type(s) {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      var black_mask = 0xf3ffc07f;\n      var n;\n      /* Check for non-textual (\"black-listed\") bytes. */\n\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !==\n        /* .Freq */\n        0) {\n          return Z_BINARY;\n        }\n      }\n      /* Check for textual (\"white-listed\") bytes. */\n\n\n      if (s.dyn_ltree[9 * 2] !==\n      /* .Freq */\n      0 || s.dyn_ltree[10 * 2] !==\n      /* .Freq */\n      0 || s.dyn_ltree[13 * 2] !==\n      /* .Freq */\n      0) {\n        return Z_TEXT;\n      }\n\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !==\n        /* .Freq */\n        0) {\n          return Z_TEXT;\n        }\n      }\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n\n\n      return Z_BINARY;\n    };\n\n    var static_init_done = false;\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n\n    var _tr_init = function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      /* Initialize the first block of the first file: */\n\n      init_block(s);\n    };\n    /* ===========================================================================\n     * Send a stored block\n     */\n\n\n    var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n    ) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      /* send block type */\n\n      copy_block(s, buf, stored_len, true);\n      /* with header */\n    };\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n\n\n    var _tr_align = function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    };\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n\n\n    var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block, or NULL if too old */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n    ) {\n      var opt_lenb;\n      var static_lenb;\n      /* opt_len and static_len in bytes */\n\n      var max_blindex = 0;\n      /* index of last bit length code of non zero freq */\n\n      /* Build the Huffman trees unless a stored block is forced */\n\n      if (s.level > 0) {\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */\n\n\n        build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n\n        max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n\n        opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5;\n        /* force a stored block */\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */\n\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n\n\n      init_block(s);\n\n      if (last) {\n        bi_windup(s);\n      } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n\n    };\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n\n\n    var _tr_tally = function _tr_tally(s, dist, lc //    deflate_state *s; //    unsigned dist;  /* distance of matched string */ //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    ) {\n      // let out_length, in_length, dcode;\n      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n      s.last_lit++;\n\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2] /* .Freq */++;\n      } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n\n        dist--;\n        /* dist = match distance - 1 */\n        // Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++;\n        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++;\n      } // (!) This block is disabled in zlib defaults,\n      // don't enable it for binary compatibility\n      // #ifdef TRUNCATE_BLOCK\n      //  /* Try to guess if it is profitable to stop the current block here */\n      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n      //    /* Compute an upper bound for the compressed length */\n      //    out_length = s.last_lit*8;\n      //    in_length = s.strstart - s.block_start;\n      //\n      //    for (dcode = 0; dcode < D_CODES; dcode++) {\n      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n      //    }\n      //    out_length >>>= 3;\n      //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n      //    //       s->last_lit, in_length, out_length,\n      //    //       100L - out_length*100L/in_length));\n      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n      //      return true;\n      //    }\n      //  }\n      // #endif\n\n\n      return s.last_lit === s.lit_bufsize - 1;\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    };\n\n    var _tr_init_1 = _tr_init;\n    var _tr_stored_block_1 = _tr_stored_block;\n    var _tr_flush_block_1 = _tr_flush_block;\n    var _tr_tally_1 = _tr_tally;\n    var _tr_align_1 = _tr_align;\n    var trees = {\n      _tr_init: _tr_init_1,\n      _tr_stored_block: _tr_stored_block_1,\n      _tr_flush_block: _tr_flush_block_1,\n      _tr_tally: _tr_tally_1,\n      _tr_align: _tr_align_1\n    }; // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var adler32 = function adler32(adler, buf, len, pos) {\n      var s1 = adler & 0xffff | 0;\n      var s2 = adler >>> 16 & 0xffff | 0;\n      var n = 0;\n\n      while (len !== 0) {\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n\n        do {\n          s1 = s1 + buf[pos++] | 0;\n          s2 = s2 + s1 | 0;\n        } while (--n);\n\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n\n      return s1 | s2 << 16 | 0;\n    };\n\n    var adler32_1 = adler32; // So write code to minimize size - no pregenerated tables\n    // and array tools dependencies.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    // Use ordinary array, since untyped makes no boost here\n\n    var makeTable = function makeTable() {\n      var c;\n      var table = [];\n\n      for (var n = 0; n < 256; n++) {\n        c = n;\n\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n        }\n\n        table[n] = c;\n      }\n\n      return table;\n    }; // Create table on load. Just 255 signed longs. Not a problem.\n\n\n    var crcTable = new Uint32Array(makeTable());\n\n    var crc32 = function crc32(crc, buf, len, pos) {\n      var t = crcTable;\n      var end = pos + len;\n      crc ^= -1;\n\n      for (var i = pos; i < end; i++) {\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xff];\n      }\n\n      return crc ^ -1; // >>> 0;\n    };\n\n    var crc32_1 = crc32; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var messages = {\n      2: 'need dictionary',\n\n      /* Z_NEED_DICT       2  */\n      1: 'stream end',\n\n      /* Z_STREAM_END      1  */\n      0: '',\n\n      /* Z_OK              0  */\n      '-1': 'file error',\n\n      /* Z_ERRNO         (-1) */\n      '-2': 'stream error',\n\n      /* Z_STREAM_ERROR  (-2) */\n      '-3': 'data error',\n\n      /* Z_DATA_ERROR    (-3) */\n      '-4': 'insufficient memory',\n\n      /* Z_MEM_ERROR     (-4) */\n      '-5': 'buffer error',\n\n      /* Z_BUF_ERROR     (-5) */\n      '-6': 'incompatible version'\n    }; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var constants = {\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      // Z_VERSION_ERROR: -6,\n\n      /* compression levels */\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n\n      /* Possible values of the data_type field (though see inflate()) */\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      // Z_ASCII:                1, // = Z_TEXT (deprecated)\n      Z_UNKNOWN: 2,\n\n      /* The deflate compression method */\n      Z_DEFLATED: 8\n    }; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var _tr_init$1 = trees._tr_init;\n    var _tr_stored_block$1 = trees._tr_stored_block;\n    var _tr_flush_block$1 = trees._tr_flush_block;\n    var _tr_tally$1 = trees._tr_tally;\n    var _tr_align$1 = trees._tr_align;\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH = constants.Z_NO_FLUSH;\n    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH;\n    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH;\n    var Z_FINISH = constants.Z_FINISH;\n    var Z_BLOCK = constants.Z_BLOCK;\n    var Z_OK = constants.Z_OK;\n    var Z_STREAM_END = constants.Z_STREAM_END;\n    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR;\n    var Z_DATA_ERROR = constants.Z_DATA_ERROR;\n    var Z_BUF_ERROR = constants.Z_BUF_ERROR;\n    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION;\n    var Z_FILTERED = constants.Z_FILTERED;\n    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY;\n    var Z_RLE = constants.Z_RLE;\n    var Z_FIXED$1 = constants.Z_FIXED;\n    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY;\n    var Z_UNKNOWN$1 = constants.Z_UNKNOWN;\n    var Z_DEFLATED = constants.Z_DEFLATED;\n    /* ============================================================================ */\n\n    var MAX_MEM_LEVEL = 9;\n    /* Maximum value for memLevel in deflateInit2 */\n\n    var MAX_WBITS = 15;\n    /* 32K LZ77 window */\n\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES$1 = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS$1 = 256;\n    /* number of literal bytes 0..255 */\n\n    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES$1 = 30;\n    /* number of distance codes */\n\n    var BL_CODES$1 = 19;\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\n    /* maximum heap size */\n\n    var MAX_BITS$1 = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    var MIN_MATCH$1 = 3;\n    var MAX_MATCH$1 = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;\n    var PRESET_DICT = 0x20;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    /* block not completed, need more input or more output */\n\n    var BS_BLOCK_DONE = 2;\n    /* block flush performed */\n\n    var BS_FINISH_STARTED = 3;\n    /* finish started, need only more output at next deflate */\n\n    var BS_FINISH_DONE = 4;\n    /* finish done, accept no more input or output */\n\n    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n    var err = function err(strm, errorCode) {\n      strm.msg = messages[errorCode];\n      return errorCode;\n    };\n\n    var rank = function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    };\n\n    var zero$1 = function zero(buf) {\n      var len = buf.length;\n\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    };\n    /* eslint-disable new-cap */\n\n\n    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n      return (prev << s.hash_shift ^ data) & s.hash_mask;\n    }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\n\n    var HASH = HASH_ZLIB;\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n\n    var flush_pending = function flush_pending(strm) {\n      var s = strm.state; // _tr_flush_bits(s);\n\n      var len = s.pending;\n\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n\n      if (len === 0) {\n        return;\n      }\n\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    };\n\n    var flush_block_only = function flush_block_only(s, last) {\n      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    };\n\n    var put_byte = function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    };\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n\n\n    var putShortMSB = function putShortMSB(s, b) {\n      //  put_byte(s, (Byte)(b >> 8));\n      //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n      s.pending_buf[s.pending++] = b & 0xff;\n    };\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n\n\n    var read_buf = function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n\n      if (len > size) {\n        len = size;\n      }\n\n      if (len === 0) {\n        return 0;\n      }\n\n      strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32_1(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32_1(strm.adler, buf, len, start);\n      }\n\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    };\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n\n\n    var longest_match = function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      /* max hash chain length */\n\n      var scan = s.strstart;\n      /* current string */\n\n      var match;\n      /* matched string */\n\n      var len;\n      /* length of current match */\n\n      var best_len = s.prev_length;\n      /* best match length so far */\n\n      var nice_match = s.nice_match;\n      /* stop if match long enough */\n\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      /* NIL */\n\n      var _win = s.window; // shortcut\n\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n\n      var strend = s.strstart + MAX_MATCH$1;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n      /* Do not waste too much time if we already have a good match: */\n\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n\n\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n\n        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n          continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n\n\n        scan += 2;\n        match++; // Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n\n        do {\n          /* jshint noempty:false */\n        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n\n        len = MAX_MATCH$1 - (strend - scan);\n        scan = strend - MAX_MATCH$1;\n\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n\n          if (len >= nice_match) {\n            break;\n          }\n\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n\n      return s.lookahead;\n    };\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n\n\n    var fill_window = function fill_window(s) {\n      var _w_size = s.w_size;\n      var p;\n      var n;\n      var m;\n      var more;\n      var str; // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n      do {\n        more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n\n        /* Deal with !@#$% 64K limit: */\n        // if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        // }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          /* we now have strstart >= MAX_DIST */\n\n          s.block_start -= _w_size;\n          /* Slide the hash table (could be avoided with 32 bit values\n          at the expense of memory usage). We slide even when level == 0\n          to keep the hash table consistent if we switch back to level > 0\n          later. (Using level 0 permanently is not an optimal usage of\n          zlib, so we don't care about this pathological case.)\n          */\n\n          n = s.hash_size;\n          p = n;\n\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n\n          n = _w_size;\n          p = n;\n\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n);\n\n          more += _w_size;\n        }\n\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        // Assert(more >= 2, \"more < 2\");\n\n\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */\n\n        if (s.lookahead + s.insert >= MIN_MATCH$1) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); // #if MIN_MATCH != 3\n          //        Call update_hash() MIN_MATCH-3 more times\n          // #endif\n\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n\n            if (s.lookahead + s.insert < MIN_MATCH$1) {\n              break;\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n      //  if (s.high_water < s.window_size) {\n      //    const curr = s.strstart + s.lookahead;\n      //    let init = 0;\n      //\n      //    if (s.high_water < curr) {\n      //      /* Previous high water mark below current data -- zero WIN_INIT\n      //       * bytes or up to end of window, whichever is less.\n      //       */\n      //      init = s.window_size - curr;\n      //      if (init > WIN_INIT)\n      //        init = WIN_INIT;\n      //      zmemzero(s->window + curr, (unsigned)init);\n      //      s->high_water = curr + init;\n      //    }\n      //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n      //      /* High water mark at or above current data, but below current data\n      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n      //       * to end of window, whichever is less.\n      //       */\n      //      init = (ulg)curr + WIN_INIT - s->high_water;\n      //      if (init > s->window_size - s->high_water)\n      //        init = s->window_size - s->high_water;\n      //      zmemzero(s->window + s->high_water, (unsigned)init);\n      //      s->high_water += init;\n      //    }\n      //  }\n      //\n      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n      //    \"not enough room for search\");\n\n    };\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n\n\n    var deflate_stored = function deflate_stored(s, flush) {\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      var max_block_size = 0xffff;\n\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      /* Copy as much as possible from input to output: */\n\n\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n          //        s.block_start >= s.w_size)) {\n          //        throw  new Error(\"slide too late\");\n          //      }\n          fill_window(s);\n\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        } // Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */\n\n        var max_start = s.block_start + max_block_size;\n\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          /** * FLUSH_BLOCK(s, 0); ** */\n\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n\n\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.strstart > s.block_start) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_NEED_MORE;\n    };\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n\n\n    var deflate_fast = function deflate_fast(s, flush) {\n      var hash_head;\n      /* head of the hash chain */\n\n      var bflush;\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n\n        hash_head = 0;\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n\n\n        if (hash_head !== 0 &&\n        /* NIL */\n        s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n        }\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n          /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n\n          if (s.match_length <= s.max_lazy_match &&\n          /* max_insert_length */\n          s.lookahead >= MIN_MATCH$1) {\n            s.match_length--;\n            /* string at strstart already in table */\n\n            do {\n              s.strstart++;\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0);\n\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); // #if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            // #endif\n\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n\n\n    var deflate_slow = function deflate_slow(s, flush) {\n      var hash_head;\n      /* head of hash chain */\n\n      var bflush;\n      /* set if current block must be flushed */\n\n      var max_insert;\n      /* Process the input block. */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n\n        hash_head = 0;\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         */\n\n\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH$1 - 1;\n\n        if (hash_head !== 0 &&\n        /* NIL */\n        s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n        /* MAX_DIST(s) */\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n\n          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)\n          /* TOO_FAR */\n          ) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH$1 - 1;\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n\n\n        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH$1;\n          /* Do not insert strings in hash table beyond this. */\n          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n\n          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n\n          do {\n            if (++s.strstart <= max_insert) {\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n            }\n          } while (--s.prev_length !== 0);\n\n          s.match_available = 0;\n          s.match_length = MIN_MATCH$1 - 1;\n          s.strstart++;\n\n          if (bflush) {\n            /** * FLUSH_BLOCK(s, 0); ** */\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n\n          if (bflush) {\n            /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n            flush_block_only(s, false);\n            /***/\n          }\n\n          s.strstart++;\n          s.lookahead--;\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n\n      if (s.match_available) {\n        // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n\n\n    var deflate_rle = function deflate_rle(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n\n      var prev;\n      /* byte at distance one to match */\n\n      var scan;\n      var strend;\n      /* scan goes up to strend for length of run */\n\n      var _win = s.window;\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH$1) {\n          fill_window(s);\n\n          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        }\n        /* See how many times the previous byte repeats */\n\n\n        s.match_length = 0;\n\n        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH$1;\n\n            do {\n              /* jshint noempty:false */\n            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\n            s.match_length = MAX_MATCH$1 - (strend - scan);\n\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n\n\n    var deflate_huff = function deflate_huff(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s);\n\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Output a literal byte */\n\n\n        s.match_length = 0; // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n\n\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n\n    var configuration_table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */\n    new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)];\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n\n    var lm_init = function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      /** * CLEAR_HASH(s); ** */\n\n      zero$1(s.head); // Fill with NIL (= 0);\n\n      /* Set the default configuration parameters:\n       */\n\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    };\n\n    function DeflateState() {\n      this.strm = null;\n      /* pointer back to this zlib stream */\n\n      this.status = 0;\n      /* as the name implies */\n\n      this.pending_buf = null;\n      /* output still pending */\n\n      this.pending_buf_size = 0;\n      /* size of pending_buf */\n\n      this.pending_out = 0;\n      /* next pending byte to output to the stream */\n\n      this.pending = 0;\n      /* nb of bytes in the pending buffer */\n\n      this.wrap = 0;\n      /* bit 0 true for zlib, bit 1 true for gzip */\n\n      this.gzhead = null;\n      /* gzip header information to write */\n\n      this.gzindex = 0;\n      /* where in extra, name, or comment */\n\n      this.method = Z_DEFLATED;\n      /* can only be DEFLATED */\n\n      this.last_flush = -1;\n      /* value of flush param for previous deflate call */\n\n      this.w_size = 0;\n      /* LZ77 window size (32K by default) */\n\n      this.w_bits = 0;\n      /* log2(w_size)  (8..16) */\n\n      this.w_mask = 0;\n      /* w_size - 1 */\n\n      this.window = null;\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n\n      this.window_size = 0;\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n\n      this.prev = null;\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n\n      this.head = null;\n      /* Heads of the hash chains or NIL. */\n\n      this.ins_h = 0;\n      /* hash index of string to be inserted */\n\n      this.hash_size = 0;\n      /* number of elements in hash table */\n\n      this.hash_bits = 0;\n      /* log2(hash_size) */\n\n      this.hash_mask = 0;\n      /* hash_size-1 */\n\n      this.hash_shift = 0;\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n\n      this.block_start = 0;\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n\n      this.match_length = 0;\n      /* length of best match */\n\n      this.prev_match = 0;\n      /* previous match */\n\n      this.match_available = 0;\n      /* set if previous match exists */\n\n      this.strstart = 0;\n      /* start of string to insert */\n\n      this.match_start = 0;\n      /* start of matching string */\n\n      this.lookahead = 0;\n      /* number of valid bytes ahead in window */\n\n      this.prev_length = 0;\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n\n      this.max_chain_length = 0;\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n\n      this.max_lazy_match = 0;\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      // this.max_insert_length = 0;\n\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n\n      this.level = 0;\n      /* compression level (1..9) */\n\n      this.strategy = 0;\n      /* favor or force Huffman coding */\n\n      this.good_match = 0;\n      /* Use a faster search when the previous match is longer than this */\n\n      this.nice_match = 0;\n      /* Stop searching when current match exceeds this */\n\n      /* used by trees.c: */\n\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n\n      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);\n      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);\n      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);\n      zero$1(this.dyn_ltree);\n      zero$1(this.dyn_dtree);\n      zero$1(this.bl_tree);\n      this.l_desc = null;\n      /* desc. for literal tree */\n\n      this.d_desc = null;\n      /* desc. for distance tree */\n\n      this.bl_desc = null;\n      /* desc. for bit length tree */\n      // ush bl_count[MAX_BITS+1];\n\n      this.bl_count = new Uint16Array(MAX_BITS$1 + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n      this.heap = new Uint16Array(2 * L_CODES$1 + 1);\n      /* heap used to build the Huffman trees */\n\n      zero$1(this.heap);\n      this.heap_len = 0;\n      /* number of elements in the heap */\n\n      this.heap_max = 0;\n      /* element of largest frequency */\n\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n\n      this.depth = new Uint16Array(2 * L_CODES$1 + 1); // uch depth[2*L_CODES+1];\n\n      zero$1(this.depth);\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n\n      this.l_buf = 0;\n      /* buffer index for literals or lengths */\n\n      this.lit_bufsize = 0;\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n\n      this.last_lit = 0;\n      /* running index in l_buf */\n\n      this.d_buf = 0;\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n\n      this.opt_len = 0;\n      /* bit length of current block with optimal trees */\n\n      this.static_len = 0;\n      /* bit length of current block with static trees */\n\n      this.matches = 0;\n      /* number of string matches in current block */\n\n      this.insert = 0;\n      /* bytes at end of window left to insert */\n\n      this.bi_buf = 0;\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n\n      this.bi_valid = 0;\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      // this.high_water = 0;\n\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n    var deflateResetKeep = function deflateResetKeep(strm) {\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN$1;\n      var s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n      : 1; // adler32(0, Z_NULL, 0)\n\n      s.last_flush = Z_NO_FLUSH;\n\n      _tr_init$1(s);\n\n      return Z_OK;\n    };\n\n    var deflateReset = function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n\n      return ret;\n    };\n\n    var deflateSetHeader = function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n\n      strm.state.gzhead = head;\n      return Z_OK;\n    };\n\n    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        // === Z_NULL\n        return Z_STREAM_ERROR;\n      }\n\n      var wrap = 1;\n\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n\n      if (windowBits < 0) {\n        /* suppress zlib wrapper */\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        /* write gzip wrapper instead */\n\n        windowBits -= 16;\n      }\n\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      /* until 256-byte window bug fixed */\n\n\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);\n      s.window = new Uint8Array(s.w_size * 2);\n      s.head = new Uint16Array(s.hash_size);\n      s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.\n      // s.high_water = 0;  /* nothing written to s->window yet */\n\n      s.lit_bufsize = 1 << memLevel + 6;\n      /* 16K elements by default */\n\n      s.pending_buf_size = s.lit_bufsize * 4; // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      // s->pending_buf = (uchf *) overlay;\n\n      s.pending_buf = new Uint8Array(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n      s.d_buf = 1 * s.lit_bufsize; // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    };\n\n    var deflateInit = function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    };\n\n    var deflate = function deflate(strm, flush) {\n      var beg;\n      var val; // for gzip header write only\n\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n\n      var s = strm.state;\n\n      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n\n      s.strm = strm;\n      /* just in case */\n\n      var old_flush = s.last_flush;\n      s.last_flush = flush;\n      /* Write the header */\n\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          // GZIP header\n          strm.adler = 0; // crc32(0L, Z_NULL, 0);\n\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n\n          if (!s.gzhead) {\n            // s->gzhead == Z_NULL\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n            put_byte(s, s.gzhead.time & 0xff);\n            put_byte(s, s.gzhead.time >> 8 & 0xff);\n            put_byte(s, s.gzhead.time >> 16 & 0xff);\n            put_byte(s, s.gzhead.time >> 24 & 0xff);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 0xff);\n\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff);\n              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n            }\n\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n            }\n\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } // DEFLATE header\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n          var level_flags = -1;\n\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n\n          header |= level_flags << 6;\n\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n\n          header += 31 - header % 31;\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          /* Save the adler32 of the preset dictionary: */\n\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 0xffff);\n          }\n\n          strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n      } // #ifdef GZIP\n\n\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n            s.gzindex++;\n          }\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff);\n            put_byte(s, strm.adler >> 8 & 0xff);\n            strm.adler = 0; // crc32(0L, Z_NULL, 0);\n\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      } // #endif\n\n      /* Flush as much pending output as possible */\n\n\n      if (s.pending !== 0) {\n        flush_pending(strm);\n\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1;\n          return Z_OK;\n        }\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* User must not provide more input after the first FINISH: */\n\n\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* Start a new block or continue the current one.\n       */\n\n\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */\n          }\n\n          return Z_OK;\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align$1(s);\n          } else if (flush !== Z_BLOCK) {\n            /* FULL_FLUSH or SYNC_FLUSH */\n            _tr_stored_block$1(s, 0, 0, false);\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n\n\n            if (flush === Z_FULL_FLUSH) {\n              /** * CLEAR_HASH(s); ** */\n\n              /* forget history */\n              zero$1(s.head); // Fill with NIL (= 0);\n\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n\n          flush_pending(strm);\n\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR at next call, see above */\n\n            return Z_OK;\n          }\n        }\n      } // Assert(strm->avail_out > 0, \"bug2\");\n      // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      /* Write the trailer */\n\n\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n\n      flush_pending(strm);\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      /* write the trailer only once! */\n\n\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    };\n\n    var deflateEnd = function deflateEnd(strm) {\n      if (!strm ||\n      /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR;\n      }\n\n      var status = strm.state.status;\n\n      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    };\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n\n\n    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n\n      if (!strm ||\n      /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR;\n      }\n\n      var s = strm.state;\n      var wrap = s.wrap;\n\n      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n      }\n\n      s.wrap = 0;\n      /* avoid computing Adler-32 in read_buf */\n\n      /* if dictionary would fill window, just replace the history */\n\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          /* already empty otherwise */\n\n          /** * CLEAR_HASH(s); ** */\n          zero$1(s.head); // Fill with NIL (= 0);\n\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n\n\n        var tmpDict = new Uint8Array(s.w_size);\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      /* insert dictionary into window and hash */\n\n\n      var avail = strm.avail_in;\n      var next = strm.next_in;\n      var input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n\n      while (s.lookahead >= MIN_MATCH$1) {\n        var str = s.strstart;\n        var n = s.lookahead - (MIN_MATCH$1 - 1);\n\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n\n        s.strstart = str;\n        s.lookahead = MIN_MATCH$1 - 1;\n        fill_window(s);\n      }\n\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    };\n\n    var deflateInit_1 = deflateInit;\n    var deflateInit2_1 = deflateInit2;\n    var deflateReset_1 = deflateReset;\n    var deflateResetKeep_1 = deflateResetKeep;\n    var deflateSetHeader_1 = deflateSetHeader;\n    var deflate_2 = deflate;\n    var deflateEnd_1 = deflateEnd;\n    var deflateSetDictionary_1 = deflateSetDictionary;\n    var deflateInfo = 'pako deflate (from Nodeca project)';\n    /* Not implemented\n    module.exports.deflateBound = deflateBound;\n    module.exports.deflateCopy = deflateCopy;\n    module.exports.deflateParams = deflateParams;\n    module.exports.deflatePending = deflatePending;\n    module.exports.deflatePrime = deflatePrime;\n    module.exports.deflateTune = deflateTune;\n    */\n\n    var deflate_1 = {\n      deflateInit: deflateInit_1,\n      deflateInit2: deflateInit2_1,\n      deflateReset: deflateReset_1,\n      deflateResetKeep: deflateResetKeep_1,\n      deflateSetHeader: deflateSetHeader_1,\n      deflate: deflate_2,\n      deflateEnd: deflateEnd_1,\n      deflateSetDictionary: deflateSetDictionary_1,\n      deflateInfo: deflateInfo\n    };\n\n    function _typeof(obj) {\n      '@babel/helpers - typeof';\n\n      if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n        _typeof = function _typeof(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    var _has = function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    };\n\n    var assign = function assign(obj\n    /* from1, from2, from3, ... */\n    ) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n\n      while (sources.length) {\n        var source = sources.shift();\n\n        if (!source) {\n          continue;\n        }\n\n        if (_typeof(source) !== 'object') {\n          throw new TypeError(source + \"must be non-object\");\n        }\n\n        for (var p in source) {\n          if (_has(source, p)) {\n            obj[p] = source[p];\n          }\n        }\n      }\n\n      return obj;\n    }; // Join array of chunks to single array.\n\n\n    var flattenChunks = function flattenChunks(chunks) {\n      // calculate data length\n      var len = 0;\n\n      for (var i = 0, l = chunks.length; i < l; i++) {\n        len += chunks[i].length;\n      } // join chunks\n\n\n      var result = new Uint8Array(len);\n\n      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n        var chunk = chunks[_i];\n        result.set(chunk, pos);\n        pos += chunk.length;\n      }\n\n      return result;\n    };\n\n    var common = {\n      assign: assign,\n      flattenChunks: flattenChunks\n    }; // String encode/decode helpers\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n\n    var STR_APPLY_UIA_OK = true;\n\n    try {\n      String.fromCharCode.apply(null, new Uint8Array(1));\n    } catch (__) {\n      STR_APPLY_UIA_OK = false;\n    } // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n\n\n    var _utf8len = new Uint8Array(256);\n\n    for (var q = 0; q < 256; q++) {\n      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n    }\n\n    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n    // convert string to array (typed, when possible)\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    function ZStream() {\n      /* next input byte */\n      this.input = null; // JS specific, because we have no pointers\n\n      this.next_in = 0;\n      /* number of bytes available at input */\n\n      this.avail_in = 0;\n      /* total number of input bytes read so far */\n\n      this.total_in = 0;\n      /* next output byte should be put there */\n\n      this.output = null; // JS specific, because we have no pointers\n\n      this.next_out = 0;\n      /* remaining free space at output */\n\n      this.avail_out = 0;\n      /* total number of bytes output so far */\n\n      this.total_out = 0;\n      /* last error message, NULL if no error */\n\n      this.msg = '';\n      /* Z_NULL */\n\n      /* not visible by applications */\n\n      this.state = null;\n      /* best guess about the data type: binary or text */\n\n      this.data_type = 2;\n      /* Z_UNKNOWN */\n\n      /* adler32 value of the uncompressed data */\n\n      this.adler = 0;\n    }\n\n    var zstream = ZStream; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    var toString = Object.prototype.toString;\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH;\n    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH;\n    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH;\n    var Z_FINISH$1 = constants.Z_FINISH;\n    var Z_OK$1 = constants.Z_OK;\n    var Z_STREAM_END$1 = constants.Z_STREAM_END;\n    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION;\n    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY;\n    var Z_DEFLATED$1 = constants.Z_DEFLATED;\n    /* =========================================================================== */\n\n    /**\n     * class Deflate\n     *\n     * Generic JS-style wrapper for zlib calls. If you don't need\n     * streaming behaviour - use more simple functions: [[deflate]],\n     * [[deflateRaw]] and [[gzip]].\n     * */\n\n    /* internal\n     * Deflate.chunks -> Array\n     *\n     * Chunks of output data, if [[Deflate#onData]] not overridden.\n     * */\n\n    /**\n     * Deflate.result -> Uint8Array\n     *\n     * Compressed result, generated by default [[Deflate#onData]]\n     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n     * */\n\n    /**\n     * Deflate.err -> Number\n     *\n     * Error code after deflate finished. 0 (Z_OK) on success.\n     * You will not need it in real life, because deflate errors\n     * are possible only on wrong options or bad `onData` / `onEnd`\n     * custom handlers.\n     * */\n\n    /**\n     * Deflate.msg -> String\n     *\n     * Error message, if [[Deflate.err]] != 0\n     * */\n\n    /**\n     * new Deflate(options)\n     * - options (Object): zlib deflate options.\n     *\n     * Creates new deflator instance with specified params. Throws exception\n     * on bad params. Supported options:\n     *\n     * - `level`\n     * - `windowBits`\n     * - `memLevel`\n     * - `strategy`\n     * - `dictionary`\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Additional options, for internal needs:\n     *\n     * - `chunkSize` - size of generated data chunks (16K by default)\n     * - `raw` (Boolean) - do raw deflate\n     * - `gzip` (Boolean) - create gzip wrapper\n     * - `header` (Object) - custom header for gzip\n     *   - `text` (Boolean) - true if compressed data believed to be text\n     *   - `time` (Number) - modification time, unix timestamp\n     *   - `os` (Number) - operation system code\n     *   - `extra` (Array) - array of bytes with extra data (max 65536)\n     *   - `name` (String) - file name (binary string)\n     *   - `comment` (String) - comment (binary string)\n     *   - `hcrc` (Boolean) - true if header crc should be added\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n     *\n     * const deflate = new pako.Deflate({ level: 3});\n     *\n     * deflate.push(chunk1, false);\n     * deflate.push(chunk2, true);  // true -> last chunk\n     *\n     * if (deflate.err) { throw new Error(deflate.err); }\n     *\n     * console.log(deflate.result);\n     * ```\n     * */\n\n    function Deflate(options) {\n      this.options = common.assign({\n        level: Z_DEFAULT_COMPRESSION$1,\n        method: Z_DEFLATED$1,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY$1\n      }, options || {});\n      var opt = this.options;\n\n      if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n      }\n\n      this.err = 0; // error code, if happens (0 = Z_OK)\n\n      this.msg = ''; // error message\n\n      this.ended = false; // used to avoid multiple onEnd() calls\n\n      this.chunks = []; // chunks of compressed data\n\n      this.strm = new zstream();\n      this.strm.avail_out = 0;\n      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\n      if (status !== Z_OK$1) {\n        throw new Error(messages[status]);\n      }\n\n      if (opt.header) {\n        deflate_1.deflateSetHeader(this.strm, opt.header);\n      }\n\n      if (opt.dictionary) {\n        var dict; // Convert data if needed\n\n        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n          dict = new Uint8Array(opt.dictionary);\n        } else {\n          dict = opt.dictionary;\n        }\n\n        status = deflate_1.deflateSetDictionary(this.strm, dict);\n\n        if (status !== Z_OK$1) {\n          throw new Error(messages[status]);\n        }\n\n        this._dict_set = true;\n      }\n    }\n    /**\n     * Deflate#push(data[, flush_mode]) -> Boolean\n     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n     *   converted to utf8 byte sequence.\n     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n     *\n     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n     * new compressed chunks. Returns `true` on success. The last data block must\n     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n     * buffers and call [[Deflate#onEnd]].\n     *\n     * On fail call [[Deflate#onEnd]] with error code and return false.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * push(chunk, false); // push one of data chunks\n     * ...\n     * push(chunk, true);  // push last chunk\n     * ```\n     * */\n\n\n    Deflate.prototype.push = function (data, flush_mode) {\n      var strm = this.strm;\n      var chunkSize = this.options.chunkSize;\n      var status;\n\n      var _flush_mode;\n\n      if (this.ended) {\n        return false;\n      }\n\n      if (flush_mode === ~~flush_mode) {\n        _flush_mode = flush_mode;\n      } else {\n        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;\n      } // Convert data if needed\n\n\n      if (toString.call(data) === '[object ArrayBuffer]') {\n        strm.input = new Uint8Array(data);\n      } else {\n        strm.input = data;\n      }\n\n      strm.next_in = 0;\n      strm.avail_in = strm.input.length;\n\n      for (;;) {\n        if (strm.avail_out === 0) {\n          strm.output = new Uint8Array(chunkSize);\n          strm.next_out = 0;\n          strm.avail_out = chunkSize;\n        } // Make sure avail_out > 6 to avoid repeating markers\n\n\n        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n\n        status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish\n\n        if (status === Z_STREAM_END$1) {\n          if (strm.next_out > 0) {\n            this.onData(strm.output.subarray(0, strm.next_out));\n          }\n\n          status = deflate_1.deflateEnd(this.strm);\n          this.onEnd(status);\n          this.ended = true;\n          return status === Z_OK$1;\n        } // Flush if out buffer full\n\n\n        if (strm.avail_out === 0) {\n          this.onData(strm.output);\n          continue;\n        } // Flush if requested and has data\n\n\n        if (_flush_mode > 0 && strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n\n        if (strm.avail_in === 0) {\n          break;\n        }\n      }\n\n      return true;\n    };\n    /**\n     * Deflate#onData(chunk) -> Void\n     * - chunk (Uint8Array): output data.\n     *\n     * By default, stores data blocks in `chunks[]` property and glue\n     * those in `onEnd`. Override this handler, if you need another behaviour.\n     * */\n\n\n    Deflate.prototype.onData = function (chunk) {\n      this.chunks.push(chunk);\n    };\n    /**\n     * Deflate#onEnd(status) -> Void\n     * - status (Number): deflate status. 0 (Z_OK) on success,\n     *   other if not.\n     *\n     * Called once after you tell deflate that the input stream is\n     * complete (Z_FINISH). By default - join collected chunks,\n     * free memory and fill `results` / `err` properties.\n     * */\n\n\n    Deflate.prototype.onEnd = function (status) {\n      // On success - join\n      if (status === Z_OK$1) {\n        this.result = common.flattenChunks(this.chunks);\n      }\n\n      this.chunks = [];\n      this.err = status;\n      this.msg = this.strm.msg;\n    };\n    /**\n     * deflate(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * Compress `data` with deflate algorithm and `options`.\n     *\n     * Supported options are:\n     *\n     * - level\n     * - windowBits\n     * - memLevel\n     * - strategy\n     * - dictionary\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Sugar (options):\n     *\n     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n     *   negative windowBits implicitly.\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n     *\n     * console.log(pako.deflate(data));\n     * ```\n     * */\n\n\n    function deflate$1(input, options) {\n      var deflator = new Deflate(options);\n      deflator.push(input, true); // That will never happens, if you don't cheat with options :)\n\n      if (deflator.err) {\n        throw deflator.msg || messages[deflator.err];\n      }\n\n      return deflator.result;\n    }\n    /**\n     * deflateRaw(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * The same as [[deflate]], but creates raw data, without wrapper\n     * (header and adler32 crc).\n     * */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    function deflateRaw(input, options) {\n      options = options || {};\n      options.raw = true;\n      return deflate$1(input, options);\n    }\n    /**\n     * gzip(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * The same as [[deflate]], but create gzip wrapper instead of\n     * deflate one.\n     * */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    function gzip(input, options) {\n      options = options || {};\n      options.gzip = true;\n      return deflate$1(input, options);\n    }\n\n    return {\n      Deflate: Deflate,\n      constants: constants\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["workerURL","createDeflateWorker","URL","createObjectURL","Blob","workerCodeFn","Worker","monitor","makePakoDeflate","Deflate","constants","deflate","rawSize","self","addEventListener","event","data","action","additionalRawSize","pushData","postMessage","id","compressedSize","chunks","reduce","total","chunk","length","push","Z_FINISH","result","binaryData","TextEncoder","encode","Z_SYNC_FLUSH","fn","apply","arguments","e","error","_","Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","set","window","subarray","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_init","_tr_stored_block","stored_len","last","_tr_align","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","strategy","_tr_tally","lit_bufsize","_tr_init_1","_tr_stored_block_1","_tr_flush_block_1","_tr_tally_1","_tr_align_1","trees","adler32","adler","pos","s1","s2","adler32_1","makeTable","table","crcTable","Uint32Array","crc32","crc","t","end","i","crc32_1","messages","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_DEFAULT_STRATEGY","Z_DEFLATED","_tr_init$1","_tr_stored_block$1","_tr_flush_block$1","_tr_tally$1","_tr_align$1","Z_FIXED$1","Z_UNKNOWN$1","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES$1","LITERALS$1","L_CODES$1","D_CODES$1","BL_CODES$1","HEAP_SIZE$1","MAX_BITS$1","MIN_MATCH$1","MAX_MATCH$1","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","errorCode","msg","zero$1","HASH_ZLIB","prev","hash_shift","hash_mask","HASH","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","more","str","window_size","hash_size","head","insert","ins_h","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","max_lazy_match","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","deflateResetKeep","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","deflateInit","beg","val","old_flush","text","hcrc","name","comment","time","os","level_flags","charCodeAt","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInit_1","deflateInit2_1","deflateReset_1","deflateResetKeep_1","deflateSetHeader_1","deflate_2","deflateEnd_1","deflateSetDictionary_1","deflateInfo","deflate_1","_typeof","obj","Symbol","iterator","constructor","prototype","_has","key","Object","hasOwnProperty","call","assign","sources","slice","source","shift","TypeError","flattenChunks","l","_i","_l","common","STR_APPLY_UIA_OK","String","fromCharCode","__","_utf8len","q","ZStream","zstream","toString","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","options","chunkSize","opt","raw","gzip","ended","Error","dict","_dict_set","flush_mode","_flush_mode","onData","onEnd","deflate$1","deflator","deflateRaw"],"sourceRoot":"","sources":["../../../src/domain/segmentCollection/deflateWorker.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}