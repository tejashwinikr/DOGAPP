{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { getOrigin, objectEntries } from '@datadog/browser-core';\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the the\n * request did not reach the server, but we the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course it might not be the case every time, but it should limit having incomplete traces a\n * bit..\n * */\n\nexport function clearTracingIfNeeded(context) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined;\n    context.spanId = undefined;\n  }\n}\nexport function startTracer(configuration) {\n  return {\n    clearTracingIfNeeded: clearTracingIfNeeded,\n    traceFetch: function traceFetch(context) {\n      return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {\n        var _a;\n\n        if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n          context.input = new Request(context.input);\n          Object.keys(tracingHeaders).forEach(function (key) {\n            ;\n            context.input.headers.append(key, tracingHeaders[key]);\n          });\n        } else {\n          context.init = __assign({}, context.init);\n          var headers_1 = [];\n\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach(function (value, key) {\n              headers_1.push([key, value]);\n            });\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach(function (header) {\n              headers_1.push(header);\n            });\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach(function (key) {\n              headers_1.push([key, context.init.headers[key]]);\n            });\n          }\n\n          context.init.headers = headers_1.concat(objectEntries(tracingHeaders));\n        }\n      });\n    },\n    traceXhr: function traceXhr(context, xhr) {\n      return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {\n        Object.keys(tracingHeaders).forEach(function (name) {\n          xhr.setRequestHeader(name, tracingHeaders[name]);\n        });\n      });\n    }\n  };\n}\n\nfunction injectHeadersIfTracingAllowed(configuration, context, inject) {\n  if (!isTracingSupported() || !isAllowedUrl(configuration, context.url)) {\n    return;\n  }\n\n  context.traceId = new TraceIdentifier();\n  context.spanId = new TraceIdentifier();\n  inject(makeTracingHeaders(context.traceId, context.spanId));\n}\n\nfunction isAllowedUrl(configuration, requestUrl) {\n  var requestOrigin = getOrigin(requestUrl);\n\n  for (var _i = 0, _a = configuration.allowedTracingOrigins; _i < _a.length; _i++) {\n    var allowedOrigin = _a[_i];\n\n    if (requestOrigin === allowedOrigin || allowedOrigin instanceof RegExp && allowedOrigin.test(requestOrigin)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined;\n}\n\nfunction getCrypto() {\n  return window.crypto || window.msCrypto;\n}\n\nfunction makeTracingHeaders(traceId, spanId) {\n  return {\n    'x-datadog-origin': 'rum',\n    'x-datadog-parent-id': spanId.toDecimalString(),\n    'x-datadog-sampled': '1',\n    'x-datadog-sampling-priority': '1',\n    'x-datadog-trace-id': traceId.toDecimalString()\n  };\n}\n/* eslint-disable no-bitwise */\n\n\nvar TraceIdentifier =\n/** @class */\nfunction () {\n  function TraceIdentifier() {\n    this.buffer = new Uint8Array(8);\n    getCrypto().getRandomValues(this.buffer);\n    this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit\n  }\n\n  TraceIdentifier.prototype.toString = function (radix) {\n    var high = this.readInt32(0);\n    var low = this.readInt32(4);\n    var str = '';\n\n    while (1) {\n      var mod = high % radix * 4294967296 + low;\n      high = Math.floor(high / radix);\n      low = Math.floor(mod / radix);\n      str = (mod % radix).toString(radix) + str;\n\n      if (!high && !low) {\n        break;\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Format used everywhere except the trace intake\n   */\n\n\n  TraceIdentifier.prototype.toDecimalString = function () {\n    return this.toString(10);\n  };\n\n  TraceIdentifier.prototype.readInt32 = function (offset) {\n    return this.buffer[offset] * 16777216 + (this.buffer[offset + 1] << 16) + (this.buffer[offset + 2] << 8) + this.buffer[offset + 3];\n  };\n\n  return TraceIdentifier;\n}();\n\nexport { TraceIdentifier };\n/* eslint-enable no-bitwise */","map":{"version":3,"mappings":"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","names":["getOrigin","objectEntries","clearTracingIfNeeded","context","status","isAborted","traceId","undefined","spanId","startTracer","configuration","traceFetch","tracingHeaders","input","Request","init","_a","headers","Object","keys","forEach","key","append","__assign","headers_1","Headers","value","push","Array","isArray","header","concat","traceXhr","xhr","name","setRequestHeader","injectHeadersIfTracingAllowed","inject","isTracingSupported","isAllowedUrl","url","TraceIdentifier","makeTracingHeaders","requestUrl","requestOrigin","allowedTracingOrigins","_i","allowedOrigin","RegExp","test","getCrypto","window","crypto","msCrypto","toDecimalString","Uint8Array","getRandomValues","buffer","radix","high","readInt32","low","str","mod","Math","floor","toString","offset"],"sourceRoot":"","sources":["../../../src/domain/tracing/tracer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}