"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeForegroundPeriod = exports.addNewForegroundPeriod = exports.startForegroundContexts = exports.MAX_NUMBER_OF_FOCUSED_TIME = void 0;
var browser_core_1 = require("@datadog/browser-core");
// Arbitrary value to cap number of element (mostly for backend)
exports.MAX_NUMBER_OF_FOCUSED_TIME = 500;
// ignore duplicate focus & blur events if coming in the right after the previous one
// chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1237904
var MAX_TIME_TO_IGNORE_DUPLICATE = 10;
var foregroundPeriods = [];
function startForegroundContexts(configuration) {
    if (!configuration.isEnabled('track-foreground')) {
        return {
            getInForeground: function () { return undefined; },
            getInForegroundPeriods: function () { return undefined; },
            stop: browser_core_1.noop,
        };
    }
    if (document.hasFocus()) {
        addNewForegroundPeriod();
    }
    var stopForegroundTracking = trackFocus(addNewForegroundPeriod).stop;
    var stopBlurTracking = trackBlur(closeForegroundPeriod).stop;
    return {
        getInForeground: getInForeground,
        getInForegroundPeriods: getInForegroundPeriods,
        stop: function () {
            foregroundPeriods = [];
            stopForegroundTracking();
            stopBlurTracking();
        },
    };
}
exports.startForegroundContexts = startForegroundContexts;
function addNewForegroundPeriod() {
    if (foregroundPeriods.length > exports.MAX_NUMBER_OF_FOCUSED_TIME) {
        browser_core_1.addMonitoringMessage('Reached maximum of foreground time');
        return;
    }
    var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
    var now = browser_core_1.relativeNow();
    if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {
        if (now - currentForegroundPeriod.start > MAX_TIME_TO_IGNORE_DUPLICATE) {
            browser_core_1.addMonitoringMessage('Previous foreground periods not closed. Continuing current one', {
                foregroundPeriods: {
                    count: foregroundPeriods.length,
                    currentStart: currentForegroundPeriod.start,
                    now: now,
                    diff: now - currentForegroundPeriod.start,
                },
            });
        }
        return;
    }
    foregroundPeriods.push({
        start: now,
    });
}
exports.addNewForegroundPeriod = addNewForegroundPeriod;
function closeForegroundPeriod() {
    if (foregroundPeriods.length === 0) {
        browser_core_1.addMonitoringMessage('No foreground period');
        return;
    }
    var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
    var now = browser_core_1.relativeNow();
    if (currentForegroundPeriod.end !== undefined) {
        if (now - currentForegroundPeriod.end > MAX_TIME_TO_IGNORE_DUPLICATE) {
            browser_core_1.addMonitoringMessage('Current foreground period already closed', {
                foregroundPeriods: {
                    count: foregroundPeriods.length,
                    currentStart: currentForegroundPeriod.start,
                    currentEnd: currentForegroundPeriod.end,
                    now: now,
                    diff: now - currentForegroundPeriod.end,
                },
                now: browser_core_1.relativeNow(),
            });
        }
        return;
    }
    currentForegroundPeriod.end = now;
}
exports.closeForegroundPeriod = closeForegroundPeriod;
function trackFocus(onFocusChange) {
    return browser_core_1.addEventListener(window, "focus" /* FOCUS */, function (event) {
        if (!event.isTrusted) {
            return;
        }
        onFocusChange();
    });
}
function trackBlur(onBlurChange) {
    return browser_core_1.addEventListener(window, "blur" /* BLUR */, function (event) {
        if (!event.isTrusted) {
            return;
        }
        onBlurChange();
    });
}
function getInForeground(startTime) {
    for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
        var foregroundPeriod = foregroundPeriods[i];
        if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {
            break;
        }
        if (startTime > foregroundPeriod.start &&
            (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)) {
            return true;
        }
    }
    return false;
}
function getInForegroundPeriods(eventStartTime, duration) {
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    var eventEndTime = (eventStartTime + duration);
    var filteredForegroundPeriods = [];
    for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
        var foregroundPeriod = foregroundPeriods[i];
        if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {
            // event starts after the end of the current focus period
            // since the array is sorted, we can stop looking for foreground periods
            break;
        }
        if (eventEndTime < foregroundPeriod.start) {
            // event ends before the start of the current focus period
            // continue to previous one
            continue;
        }
        var startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start;
        var startDuration = browser_core_1.elapsed(eventStartTime, startTime);
        var endTime = foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end;
        var endDuration = browser_core_1.elapsed(startTime, endTime);
        filteredForegroundPeriods.unshift({
            start: browser_core_1.toServerDuration(startDuration),
            duration: browser_core_1.toServerDuration(endDuration),
        });
    }
    return filteredForegroundPeriods;
}
//# sourceMappingURL=foregroundContexts.js.map