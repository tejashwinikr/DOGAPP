import { noop, addEventListener, elapsed, relativeNow, addMonitoringMessage, toServerDuration, } from '@datadog/browser-core';
// Arbitrary value to cap number of element (mostly for backend)
export var MAX_NUMBER_OF_FOCUSED_TIME = 500;
// ignore duplicate focus & blur events if coming in the right after the previous one
// chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1237904
var MAX_TIME_TO_IGNORE_DUPLICATE = 10;
var foregroundPeriods = [];
export function startForegroundContexts(configuration) {
    if (!configuration.isEnabled('track-foreground')) {
        return {
            getInForeground: function () { return undefined; },
            getInForegroundPeriods: function () { return undefined; },
            stop: noop,
        };
    }
    if (document.hasFocus()) {
        addNewForegroundPeriod();
    }
    var stopForegroundTracking = trackFocus(addNewForegroundPeriod).stop;
    var stopBlurTracking = trackBlur(closeForegroundPeriod).stop;
    return {
        getInForeground: getInForeground,
        getInForegroundPeriods: getInForegroundPeriods,
        stop: function () {
            foregroundPeriods = [];
            stopForegroundTracking();
            stopBlurTracking();
        },
    };
}
export function addNewForegroundPeriod() {
    if (foregroundPeriods.length > MAX_NUMBER_OF_FOCUSED_TIME) {
        addMonitoringMessage('Reached maximum of foreground time');
        return;
    }
    var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
    var now = relativeNow();
    if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {
        if (now - currentForegroundPeriod.start > MAX_TIME_TO_IGNORE_DUPLICATE) {
            addMonitoringMessage('Previous foreground periods not closed. Continuing current one', {
                foregroundPeriods: {
                    count: foregroundPeriods.length,
                    currentStart: currentForegroundPeriod.start,
                    now: now,
                    diff: now - currentForegroundPeriod.start,
                },
            });
        }
        return;
    }
    foregroundPeriods.push({
        start: now,
    });
}
export function closeForegroundPeriod() {
    if (foregroundPeriods.length === 0) {
        addMonitoringMessage('No foreground period');
        return;
    }
    var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
    var now = relativeNow();
    if (currentForegroundPeriod.end !== undefined) {
        if (now - currentForegroundPeriod.end > MAX_TIME_TO_IGNORE_DUPLICATE) {
            addMonitoringMessage('Current foreground period already closed', {
                foregroundPeriods: {
                    count: foregroundPeriods.length,
                    currentStart: currentForegroundPeriod.start,
                    currentEnd: currentForegroundPeriod.end,
                    now: now,
                    diff: now - currentForegroundPeriod.end,
                },
                now: relativeNow(),
            });
        }
        return;
    }
    currentForegroundPeriod.end = now;
}
function trackFocus(onFocusChange) {
    return addEventListener(window, "focus" /* FOCUS */, function (event) {
        if (!event.isTrusted) {
            return;
        }
        onFocusChange();
    });
}
function trackBlur(onBlurChange) {
    return addEventListener(window, "blur" /* BLUR */, function (event) {
        if (!event.isTrusted) {
            return;
        }
        onBlurChange();
    });
}
function getInForeground(startTime) {
    for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
        var foregroundPeriod = foregroundPeriods[i];
        if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {
            break;
        }
        if (startTime > foregroundPeriod.start &&
            (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)) {
            return true;
        }
    }
    return false;
}
function getInForegroundPeriods(eventStartTime, duration) {
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    var eventEndTime = (eventStartTime + duration);
    var filteredForegroundPeriods = [];
    for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
        var foregroundPeriod = foregroundPeriods[i];
        if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {
            // event starts after the end of the current focus period
            // since the array is sorted, we can stop looking for foreground periods
            break;
        }
        if (eventEndTime < foregroundPeriod.start) {
            // event ends before the start of the current focus period
            // continue to previous one
            continue;
        }
        var startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start;
        var startDuration = elapsed(eventStartTime, startTime);
        var endTime = foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end;
        var endDuration = elapsed(startTime, endTime);
        filteredForegroundPeriods.unshift({
            start: toServerDuration(startDuration),
            duration: toServerDuration(endDuration),
        });
    }
    return filteredForegroundPeriods;
}
//# sourceMappingURL=foregroundContexts.js.map