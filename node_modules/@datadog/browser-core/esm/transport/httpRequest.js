import { monitor, addErrorToMonitoringBatch, addMonitoringMessage } from '../domain/internalMonitoring';
import { generateUUID, includes } from '../tools/utils';
var hasReportedXhrError = false;
/**
 * Use POST request without content type to:
 * - avoid CORS preflight requests
 * - allow usage of sendBeacon
 *
 * multiple elements are sent separated by \n in order
 * to be parsed correctly without content type header
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(endpointUrl, bytesLimit, withBatchTime) {
        if (withBatchTime === void 0) { withBatchTime = false; }
        this.endpointUrl = endpointUrl;
        this.bytesLimit = bytesLimit;
        this.withBatchTime = withBatchTime;
    }
    HttpRequest.prototype.send = function (data, size) {
        var url = addQueryParameter(this.endpointUrl, 'dd-request-id', generateUUID());
        if (this.withBatchTime) {
            url = addQueryParameter(url, 'batch_time', new Date().getTime().toString());
        }
        var tryBeacon = !!navigator.sendBeacon && size < this.bytesLimit;
        if (tryBeacon) {
            try {
                var isQueued = navigator.sendBeacon(url, data);
                if (isQueued) {
                    return;
                }
            }
            catch (e) {
                reportBeaconError(e);
            }
        }
        var transportIntrospection = function (event) {
            var req = event === null || event === void 0 ? void 0 : event.currentTarget;
            if (req.status >= 200 && req.status < 300) {
                return;
            }
            if (!hasReportedXhrError) {
                hasReportedXhrError = true;
                addMonitoringMessage('XHR fallback failed', {
                    on_line: navigator.onLine,
                    size: size,
                    url: url,
                    try_beacon: tryBeacon,
                    event: {
                        is_trusted: event.isTrusted,
                        total: event.total,
                        loaded: event.loaded,
                    },
                    request: {
                        status: req.status,
                        ready_state: req.readyState,
                        response_text: req.responseText.slice(0, 64),
                    },
                });
            }
        };
        var request = new XMLHttpRequest();
        request.addEventListener('loadend', monitor(function (event) { return transportIntrospection(event); }));
        request.open('POST', url, true);
        request.send(data);
    };
    return HttpRequest;
}());
export { HttpRequest };
function addQueryParameter(url, key, value) {
    return "" + url + (includes(url, '?') ? '&' : '?') + key + "=" + value;
}
var hasReportedBeaconError = false;
function reportBeaconError(e) {
    if (!hasReportedBeaconError) {
        hasReportedBeaconError = true;
        addErrorToMonitoringBatch(e);
    }
}
//# sourceMappingURL=httpRequest.js.map