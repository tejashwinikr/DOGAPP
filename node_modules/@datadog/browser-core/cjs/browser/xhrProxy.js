"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetXhrProxy = exports.startXhrProxy = void 0;
var tslib_1 = require("tslib");
var internalMonitoring_1 = require("../domain/internalMonitoring");
var timeUtils_1 = require("../tools/timeUtils");
var urlPolyfill_1 = require("../tools/urlPolyfill");
var xhrProxySingleton;
var beforeSendCallbacks = [];
var onRequestCompleteCallbacks = [];
var originalXhrOpen;
var originalXhrSend;
var originalXhrAbort;
function startXhrProxy() {
    if (!xhrProxySingleton) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalXhrOpen = XMLHttpRequest.prototype.open;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalXhrSend = XMLHttpRequest.prototype.send;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalXhrAbort = XMLHttpRequest.prototype.abort;
        XMLHttpRequest.prototype.open = openXhr;
        XMLHttpRequest.prototype.send = sendXhr;
        XMLHttpRequest.prototype.abort = abortXhr;
        xhrProxySingleton = {
            beforeSend: function (callback) {
                beforeSendCallbacks.push(callback);
            },
            onRequestComplete: function (callback) {
                onRequestCompleteCallbacks.push(callback);
            },
        };
    }
    return xhrProxySingleton;
}
exports.startXhrProxy = startXhrProxy;
function resetXhrProxy() {
    if (xhrProxySingleton) {
        xhrProxySingleton = undefined;
        beforeSendCallbacks.length = 0;
        onRequestCompleteCallbacks.length = 0;
        XMLHttpRequest.prototype.open = originalXhrOpen;
        XMLHttpRequest.prototype.send = originalXhrSend;
        XMLHttpRequest.prototype.abort = originalXhrAbort;
    }
}
exports.resetXhrProxy = resetXhrProxy;
function openXhr(method, url) {
    var _this = this;
    internalMonitoring_1.callMonitored(function () {
        // WARN: since this data structure is tied to the instance, it is shared by both logs and rum
        // and can be used by different code versions depending on customer setup
        // so it should stay compatible with older versions
        _this._datadog_xhr = {
            method: method,
            url: urlPolyfill_1.normalizeUrl(url),
        };
    });
    return originalXhrOpen.apply(this, arguments);
}
function sendXhr() {
    var _this = this;
    internalMonitoring_1.callMonitored(function () {
        if (!_this._datadog_xhr) {
            return;
        }
        _this._datadog_xhr.startTime = timeUtils_1.relativeNow();
        _this._datadog_xhr.startClocks = timeUtils_1.clocksNow();
        _this._datadog_xhr.isAborted = false;
        var hasBeenReported = false;
        var originalOnreadystatechange = _this.onreadystatechange;
        var onreadystatechange = function () {
            if (this.readyState === XMLHttpRequest.DONE) {
                // Try to report the XHR as soon as possible, because the XHR may be mutated by the
                // application during a future event. For example, Angular is calling .abort() on
                // completed requests during a onreadystatechange event, so the status becomes '0'
                // before the request is collected.
                onEnd();
            }
            if (originalOnreadystatechange) {
                originalOnreadystatechange.apply(this, arguments);
            }
        };
        var onEnd = internalMonitoring_1.monitor(function () {
            _this.removeEventListener('loadend', onEnd);
            // if the onreadystatechange hasn't been overridden by the user after the send()
            if (_this.onreadystatechange === onreadystatechange) {
                _this.onreadystatechange = originalOnreadystatechange;
            }
            if (hasBeenReported) {
                return;
            }
            hasBeenReported = true;
            reportXhr(_this);
        });
        _this.onreadystatechange = onreadystatechange;
        _this.addEventListener('loadend', onEnd);
        beforeSendCallbacks.forEach(function (callback) { return callback(_this._datadog_xhr, _this); });
    });
    return originalXhrSend.apply(this, arguments);
}
function abortXhr() {
    var _this = this;
    internalMonitoring_1.callMonitored(function () {
        if (_this._datadog_xhr) {
            _this._datadog_xhr.isAborted = true;
        }
    });
    return originalXhrAbort.apply(this, arguments);
}
function reportXhr(xhr) {
    xhr._datadog_xhr.duration = timeUtils_1.elapsed(xhr._datadog_xhr.startClocks.timeStamp, timeUtils_1.timeStampNow());
    xhr._datadog_xhr.responseText = xhr.response;
    xhr._datadog_xhr.status = xhr.status;
    xhr._datadog_xhr.xhr = xhr;
    onRequestCompleteCallbacks.forEach(function (callback) { return callback(tslib_1.__assign({}, xhr._datadog_xhr)); });
}
//# sourceMappingURL=xhrProxy.js.map